/*
************************************
*          Fetch & async           * 
************************************ 
*/

//--- ASINCRON√çA ---//
/*
MODELOS DE PROGRAMACI√ìN SINCR√ìNICA Y ASINCR√ìNICA

En el mmodelo sincronico nuestro programa funciona de manera lineal, ejecutando una acci√≥n y despu√©s otra. S√≥lo podemos realizar una tarea a la vez y cada tarea es bloqueante de la siguiente.

El modelo asincronico podemos realizar m√∫ltiples tareas a la vez. Al comenzar una acci√≥n, nuestro programa sigue en ejecuci√≥n; y cuando la acci√≥n termina nuestro programa es informado y consigue acceso al resultado correspondiente

ENTONCES‚Ä¶
SI DESEO HACER DOS PETICIONES

Modelo Sincr√≥nico
La segunda petici√≥n empezar√≠a solamente cuando termine la primera, y tendr√≠amos el resultado de ambas luego de finalizar la segunda.

Modelo Asincr√≥nico
Ambas peticiones pueden realizarse en paralelo, y s√≥lo debemos sincronizar los resultados cuando terminen.
*/

//--- PROGRAMACI√ìN ASINCR√ìNICA ---//
/*
üëç Una de las principales ventajas del modelo asincr√≥nico: facilita el manejo de programas que realizan m√∫ltiples acciones a la vez.
‚úã Uno de sus principales riesgos: puede dificultar la comprensi√≥n de aquellos programas que tienden a seguir una √∫nica l√≠nea de acci√≥n
*/

//--- setTimeout ---//
/*
Es una funci√≥n que permite realizar acciones asincr√≥nicamente.
La funci√≥n recibe dos par√°metros:
Una funci√≥n de callback y un valor num√©rico que representa milisegundos

setTimeout(fn, time)

As√≠, la funci√≥n que pasamos por primer par√°metro se ejecuta luego de que transcurra el tiempo definido en el segundo par√°metro. Por ejemplo:

setTimeout(()=> {
    console.log("Proceso asincr√≥nico")
}, 3000)

En modelo sincr√≥nico, esperar√≠amos ver el pr√≥ximo ejemplo en el siguiente orden:
‚ÄúInicia proceso‚Äù
‚ÄúMitad de proceso‚Äù (tras 2 segundos)
‚ÄúFin proceso‚Äù

console.log("Inicia proceso")

setTimeout(()=> {
    console.log("Mitad de proceso")
}, 2000)

console.log("Fin proceso")

Sin embargo, la salida se produce de la siguiente forma:

// Inicia proceso
// Fin proceso

// Mitad de proceso  - tras 2 segundos

Esto sucede porque setTimeout funciona de forma asincr√≥nica. Por eso es que los dos console.log se ejecutan antes, y por √∫ltimo vemos el resultado del setTimeout que va en el medio.

EJEMPLO DE APLICACI√ìN DE SETTIMEOUT
Podemos estilar un elemento del DOM tras un evento y removerle una clase tras cierto tiempo:

const btn = document.querySelector('#boton')
const popup = document.querySelector('#popup-mensaje')

btn.addEventListener('click', () => {
    popup.classList.add('popup-active')

    setTimeout(() => {
        popup.classList.remove('popup-active')
    }, 2500)
})

Aqu√≠ se agrega una clase a un elemento tras clickear un bot√≥n, y luego se dispara un setTimeout que remueve esa clase del elemento tras 2500 milisegundos. 
Permite automatizar un evento interactivo.

Para casos sencillos asociados a eventos, lo visto en el ejemplo anterior puede resultar muy conveniente. 
Sin embargo, el problema est√° cuando tratamos combinar de forma compleja ambos tipos de procesos.
*/

//--- EJEMPLO DE APLICACI√ìN DE SETTIMEOUT ---//
/*
De forma sincr√≥nica, esperamos ver en vertical un console.log de cada letra de ambos strings, uno despu√©s del otro:
for (let letra of "hola") {
    console.log(letra)
}

for (let letra of "mundo") {
    console.log(letra)
}

Salida:
-
h
o
l
a
m
u
n
d
o
-

¬øQu√© pasa cuando dentro de los iteradores agregamos un setTimeout a cada console.log? El iterador ejecuta de forma sincr√≥nica los llamados al setTimeout por cada letra, y estos se resuelven en orden con el delay correspondiente de forma asincr√≥nica:
*/

//--- CALL STACK ---//
/*
CALL STACK (PILA)
Es una lista donde se apilan las distintas tareas a ejecutar por nuestro programa. Javascript es un lenguaje single threaded, o de un √∫nico hilo, lo que significa que tiene un √∫nico stack o pila de ejecuci√≥n. De ah√≠ que la ejecuci√≥n es impl√≠citamente sincr√≥nica.

¬øC√≥mo es el proceso de Call Stack?
Cuando se est√° a punto de ejecutar una funci√≥n, √©sta es a√±adida al stack. Si la funci√≥n llama a la vez, a otra funci√≥n, √©sta es agregada sobre la anterior:

function multiply (x, y) {    
    return x * y;
}

function printSquare (x) {    
    let s = multiply(x, x);    
    console.log(s);
}

printSquare(5);
*/

//--- EVENT LOOP ---//
/*
Muchas funciones asincr√≥nicas se ejecutan en un stack diferente. El Event Loop es la herramienta que permite la sincronizaci√≥n entre nuestro call stack con estas tareas asincr√≥nicas que funcionan en un thread aparte.
Si el stack est√° vac√≠o, el Event Loop env√≠a la primera funci√≥n que est√© en la callback queue al call stack y comienza a ejecutarse.

As√≠, entendemos c√≥mo funciona de tal manera una instrucci√≥n como la siguiente

console.log("Inicia proceso")

setTimeout(()=> {
    console.log("Mitad de proceso")
}, 0)

console.log("Fin proceso")

// Inicia proceso
// Fin proceso
// Mitad de proceso 

Por m√°s que hagamos el timeout con 0 milisegundos, √©ste se env√≠a al stack de web apis primero, luego al callback queue, y finalmente el event loop lo incorpora al callstack para su ejecuci√≥n, luego de los console.log anteriores
*/

//--- setInterval ---//
/*
Tiene la misma sintaxis que setTimeout, pero la unidad de tiempo es un intervalo para la repetici√≥n de la funci√≥n asociada:

setInterval(() => {
    console.log("Tic")
}, 1000)

Permite ejecutar funciones de manera reiterativa tras los milisegundos indicados hasta que indiquemos su detenci√≥n o se cierre la aplicaci√≥n
*/

//--- clearInterval & clearTimeout ---//
/*
En caso de querer remover un Intervalo, utilizamos la funci√≥n clearInterval (). Tambi√©n podemos detener la ejecuci√≥n de un setTimeout invocando clearTimeout ().

Cuando llamamos un setInterval() √©ste retorna una referencia al intervalo generado, el cual podemos almacenar en una variable. Es esta referencia la que debemos pasar a la funci√≥n clearInterval para que la limpieza tenga efecto:

let counter = 0

const interval = setInterval(() => {
    counter++
    console.log("Counter: ", counter)

    if (counter >= 5) {
        clearInterval(interval)
        console.log("Se removi√≥ el intervalo")
    }
}, 1000)

Funciona igual con los timeout. Si guardamos en una variable la referencia al timeout generado, podemos usarla para removerlo luego. En el siguiente caso, el timeout generado nunca llega a ejecutarse:

console.log("Inicio")

const fin = setTimeout(() => {
    console.log("fin")
}, 2000)

clearTimeout(fin)
*/

/*
************************************
*             Promesas             * 
************************************ 
*/
/*
¬øQU√â ES UNA PROMESA EN JS?

Es un objeto de Javascript que representa un evento a futuro. Es una acci√≥n asincr√≥nica que se puede completar en alg√∫n momento y producir un valor, y notificar cuando esto suceda.
Una promesa cuenta con tres estados posibles: pending, fulfilled y rejected. Las promesas pueden de ser resueltas o rechazadas.

Podemos crear promesas a trav√©s de su constructor new Promise. Su sintaxis es algo compleja, ya que recibe una funci√≥n por par√°metro que a su vez recibe por par√°metro las funciones de resolve y reject

new Promise( (resolve, reject) => {
    //cuerpo de la promesa
})
*/

//--- Resolve & Reject ---//
/*
En principio, una promesa se retorna con estado pending, entendiendo que el valor a generar a√∫n no fue resuelto:

const eventoFuturo = () => {
    return new Promise( (resolve, reject) => {
        //cuerpo de la promesa
    } )
}

console.log( eventoFuturo() ) // Promise { <pending> }

Esta funci√≥n retorna una promesa que no se resuelve. Por lo tanto, veremos que el valor que genera es un objeto Promise con estado pendiente.

El valor de retorno de la promesa se define a trav√©s del llamado a las funciones de resolve o reject:
Si el cuerpo de la promesa llama a resolve(), la promesa cambiar√° su estado a fulfilled, con el valor enviado a resolve().
Si la promesa llama a reject(), cambiar√° su estado a rejected con el valor enviado al reject().
*/

//--- EJEMPLO ---//
/*
Aqu√≠ podemos ver c√≥mo cambia de estado la promesa con distintos valores. Seg√∫n el llamado de la funci√≥n la promesa se ver√° resuelta o rechazada. Sin embargo, lo que vemos por consola es el objeto Promise que retorna la funci√≥n, y con lo que nos interesa trabajar en realidad es con el valor de resoluci√≥n de la promesa. 

const eventoFuturo = (res) => {
    return new Promise( (resolve, reject) => {
        if (res === true) {
            resolve('Promesa resuelta')
        } else {
            reject('Promesa rechazada')
        }
    })
}

console.log( eventoFuturo(true) ) // Promise { 'Promesa resuelta' }
console.log( eventoFuturo(false) ) // Promise { <rejected> 'Promesa rechazada' }

Miremos el mismo caso agregando un delay con setTimeout:

const eventoFuturo = (res) => {
    return new Promise( (resolve, reject) => {
        setTimeout( () => {
            res ? resolve('Promesa resuelta') : reject('Promesa rechazada')
        }, 2000)
    })
}

console.log( eventoFuturo(true) ) // Promise { <pending> }
console.log( eventoFuturo(false) ) // Promise { <pending> }

En este caso, el console.log es sincr√≥nico y vemos que la promesa est√° en pending en ambos llamados (su resoluci√≥n se generar√° dentro de 2s). Las promesas tienen un mecanismo para trabajar esta asincron√≠a y poder ejecutar funciones cuando cambie su estado.
*/

//--- THEN & CATCH ---//
/*
Al llamado de una funci√≥n que retorne una promesa, podemos concatenar el m√©todo .then() o .catch(), los cuales reciben una funci√≥n por par√°metro con la cual se captura el valor de la promesa:
.then() : Si la promesa es resuelta , su valor de retorno se captura dentro del .then(), recibiendo por par√°metro de su funci√≥n ese valor.
.catch() : si la promesa es rechazada , su valor se captura dentro de un .catch() siguiendo la misma l√≥gica.

Lo que queramos ejecutar cuando la promesa se resuelva o rechace, debemos definirlo dentro de un .then() o .catch(), seg√∫n el caso üôå:

eventoFuturo(true)
    .then( (response) => {
        console.log(response) // Promesa resuelta
    })

eventoFuturo(false)
    .catch( (error) => {
        console.log(error) // Promesa rechazada
    })

Se aprecian los console.log tras 2 segundos de delay y lo que vemos es, precisamente, el valor que retornan el resolve o reject de la promesa.

Como una promesa puede tener varios estados posibles, se puede concatenar varios .then() o .catch() en un mismo llamado, y caeremos en el caso que corresponda seg√∫n c√≥mo se haya resuelto la promesa.

eventoFuturo(true)
    .then( (response) => {
        console.log(response) // Promesa resuelta
    })
    .catch( (error) => {
        console.log(error)
    })

eventoFuturo(false)
    .then( (response) => {
        console.log(response)
    })
    .catch( (error) => {
        console.log(error) // Promesa rechazada
    })

*/

//--- FINALLY ---//
/*
finally() es un m√©todo que recibe una funci√≥n la cual se ejecutar√° siempre al finalizar la secuencia, sin importar si se haya resuelto o no la promesa:

eventoFuturo(true)
    .then( (response) => {
        console.log(response)
    })
    .catch( (error) => {
        console.log(error)
    })
    .finally( () => {
        console.log("Fin del proceso")
    })
// Promesa resuelta
// Fin del proceso

*/